Etapa 1:
Chegada √† Ilha e Invent√°rio B√°sico (Structs e Listas Sequenciais/Vetores)

A. Estrutura de Dados Base 

/ item.h
#define MAX_INVENTORY_SIZE 20 // Limite da mochila

// Define as categorias de itens
typedef enum {
    FOOD,        // Alimentos (Cura, Stamina)
    WEAPON,      // Armas (Dano, Alcance)
    TOOL,        // Ferramentas (Constru√ß√£o, Coleta)
    PRIORITY_ITEM // Itens Chave para Fuga
} ItemType;

// Estrutura de um Item gen√©rico
typedef struct {
    int id;
    char name[50];
    ItemType type;
    int weight; // Peso ou volume (para controle de capacidade)
    int value;  // Valor de uso (ex: dano da arma, cura do alimento)
} Item;

// Estrutura do Invent√°rio (Lista Sequencial/Vetor)
typedef struct {
    Item items[MAX_INVENTORY_SIZE]; // O vetor armazena os itens
    int count;                      // Contador de itens atuais
} Inventory;

B. Implementa√ß√£o da L√≥gica de Invent√°rio

Fun√ß√£o	                   Descri√ß√£o                                                                        	Estrutura
initializeInventory()	    Inicializa o count para 0.	                                                        Inventory
addItem(Inv, Item)      	Adiciona um item, verificando se a capacidade (MAX_INVENTORY_SIZE) foi atingida.	  Vetor (Lista Seq.)
removeItem(Inv, id)      	Remove um item por ID.	                                                            Busca Linear + Deslocamento de elementos
displayInventory(Inv)	    Mostra todos os itens e a capacidade usada.                                         Loop Simples


 Etapa 2: Coleta de Recursos e Otimiza√ß√£o (Listas Encadeadas e Busca Bin√°ria)
Nesta fase, o desafio √© comparar a efici√™ncia do vetor (Invent√°rio) com uma Lista Encadeada para os recursos coletados e introduzir uma busca otimizada.

A. Estrutura de Dados para Recursos (Resource.h)

// resource.h
// Estrutura do N√≥ da Lista Encadeada
typedef struct ResourceNode {
    char name[50];
    int quantity;
    struct ResourceNode *next;
} ResourceNode;

// Estrutura da Lista Encadeada
typedef struct {
    ResourceNode *head;
    int size;
} ResourceList; 

B. Implementa√ß√£o da L√≥gica de Recursos

Fun√ß√£o	Descri√ß√£o	Vantagem da Lista Encadeada
addResource(List, name, qty)	Insere um recurso no in√≠cio ou fim da lista.	Inser√ß√£o O(1) ou O(n): N√£o exige deslocamento na mem√≥ria como um vetor.
removeResource(List, name)	Remove um recurso espec√≠fico.	Remo√ß√£o O(1): Ap√≥s encontrar o n√≥, a remo√ß√£o √© instant√¢nea, sem deslocamento.
findResource(List, name)	Procura um recurso.	Busca Linear O(n), mas a flexibilidade compensa.

Desafio TechNova: Mini Game de Sobreviv√™ncia em C (Free Fire)Este √© um projeto ambicioso que exige o dom√≠nio de estruturas de dados e algoritmos em C. A base para um sistema eficiente e escal√°vel √© a modulariza√ß√£o e a escolha correta das estruturas para cada componente (Invent√°rio, Itens, Recursos).Abaixo est√° o plano de implementa√ß√£o estruturado para o seu projeto, dividido nas tr√™s etapas propostas, utilizando C.1. üéí Etapa 1: Chegada √† Ilha e Invent√°rio B√°sico (Structs e Listas Sequenciais/Vetores)Nesta fase, o foco √© estabelecer as estruturas de dados fundamentais e a l√≥gica de intera√ß√£o b√°sica.A. Estrutura de Dados Base (Item.h)Utilizaremos structs para modelar os itens e o invent√°rio.C// item.h
#define MAX_INVENTORY_SIZE 20 // Limite da mochila

// Define as categorias de itens
typedef enum {
    FOOD,        // Alimentos (Cura, Stamina)
    WEAPON,      // Armas (Dano, Alcance)
    TOOL,        // Ferramentas (Constru√ß√£o, Coleta)
    PRIORITY_ITEM // Itens Chave para Fuga
} ItemType;

// Estrutura de um Item gen√©rico
typedef struct {
    int id;
    char name[50];
    ItemType type;
    int weight; // Peso ou volume (para controle de capacidade)
    int value;  // Valor de uso (ex: dano da arma, cura do alimento)
} Item;

// Estrutura do Invent√°rio (Lista Sequencial/Vetor)
typedef struct {
    Item items[MAX_INVENTORY_SIZE]; // O vetor armazena os itens
    int count;                      // Contador de itens atuais
} Inventory;

 Desafio TechNova: Mini Game de Sobreviv√™ncia em C (Free Fire)Este √© um projeto ambicioso que exige o dom√≠nio de estruturas de dados e algoritmos em C. A base para um sistema eficiente e escal√°vel √© a modulariza√ß√£o e a escolha correta das estruturas para cada componente (Invent√°rio, Itens, Recursos).Abaixo est√° o plano de implementa√ß√£o estruturado para o seu projeto, dividido nas tr√™s etapas propostas, utilizando C.1. üéí Etapa 1: Chegada √† Ilha e Invent√°rio B√°sico (Structs e Listas Sequenciais/Vetores)Nesta fase, o foco √© estabelecer as estruturas de dados fundamentais e a l√≥gica de intera√ß√£o b√°sica.A. Estrutura de Dados Base (Item.h)Utilizaremos structs para modelar os itens e o invent√°rio.C// item.h
#define MAX_INVENTORY_SIZE 20 // Limite da mochila

// Define as categorias de itens
typedef enum {
    FOOD,        // Alimentos (Cura, Stamina)
    WEAPON,      // Armas (Dano, Alcance)
    TOOL,        // Ferramentas (Constru√ß√£o, Coleta)
    PRIORITY_ITEM // Itens Chave para Fuga
} ItemType;

// Estrutura de um Item gen√©rico
typedef struct {
    int id;
    char name[50];
    ItemType type;
    int weight; // Peso ou volume (para controle de capacidade)
    int value;  // Valor de uso (ex: dano da arma, cura do alimento)
} Item;

// Estrutura do Invent√°rio (Lista Sequencial/Vetor)
typedef struct {
    Item items[MAX_INVENTORY_SIZE]; // O vetor armazena os itens
    int count;                      // Contador de itens atuais
} Inventory;
B. Implementa√ß√£o da L√≥gica de Invent√°rio (inventory.c)Usamos fun√ß√µes para gerenciar a lista sequencial (o vetor items).Fun√ß√£oDescri√ß√£oEstruturainitializeInventory()Inicializa o count para 0.InventoryaddItem(Inv, Item)Adiciona um item, verificando se a capacidade (MAX_INVENTORY_SIZE) foi atingida.Vetor (Lista Seq.)removeItem(Inv, id)Remove um item por ID.Busca Linear + Deslocamento de elementosdisplayInventory(Inv)Mostra todos os itens e a capacidade usada.Loop SimplesC. Desafio da Fase: Busca Linear e Ordena√ß√£o SimplesBusca Linear: Implementar a busca de um item por name ou id percorrendo o vetor (removeItem usar√° isso).Ordena√ß√£o Simples (Insertion Sort): Implementar um algoritmo simples para ordenar o invent√°rio por id ap√≥s a inicializa√ß√£o.2. üå≥ Etapa 2: Coleta de Recursos e Otimiza√ß√£o (Listas Encadeadas e Busca Bin√°ria)Nesta fase, o desafio √© comparar a efici√™ncia do vetor (Invent√°rio) com uma Lista Encadeada para os recursos coletados e introduzir uma busca otimizada.A. Estrutura de Dados para Recursos (Resource.h)Para recursos (madeira, pedra, metal), que s√£o coletados e descartados de forma mais din√¢mica, uma Lista Encadeada √© mais eficiente, pois evita o deslocamento de elementos na mem√≥ria.C// resource.h
// Estrutura do N√≥ da Lista Encadeada
typedef struct ResourceNode {
    char name[50];
    int quantity;
    struct ResourceNode *next;
} ResourceNode;

// Estrutura da Lista Encadeada
typedef struct {
    ResourceNode *head;
    int size;
} ResourceList;

B. Implementa√ß√£o da L√≥gica de Recursos (resource.c)Fun√ß√£oDescri√ß√£oVantagem da Lista EncadeadaaddResource(List, name, qty)Insere um recurso no in√≠cio ou fim da lista.Inser√ß√£o O(1) ou O(n): N√£o exige deslocamento na mem√≥ria como um vetor.removeResource(List, name)Remove um recurso espec√≠fico.Remo√ß√£o O(1): Ap√≥s encontrar o n√≥, a remo√ß√£o √© instant√¢nea, sem deslocamento.findResource(List, name)Procura um recurso.Busca Linear O(n), mas a flexibilidade compensa.C. Desafio da Fase: Busca Bin√°ria em Vetores OrdenadosPara o Invent√°rio de Itens (que √© um vetor), se mantivermos ele sempre ordenado (por id ou name), podemos usar a Busca Bin√°ria.Pr√©-requisito: O invent√°rio deve estar ordenado.Busca Bin√°ria: Implementar uma fun√ß√£o searchItem(Inventory, name) que utiliza a busca bin√°ria.$$O(log \, n) < O(n)$$Vantagem: Se o Invent√°rio for grande, a Busca Bin√°ria √© drasticamente mais r√°pida que a Busca Linear.3. üóº Etapa 3: Estrat√©gia de Fuga e Otimiza√ß√£o Avan√ßada (Selection Sort e Torre de Fuga)A fase final exige a aplica√ß√£o de algoritmos mais complexos para a organiza√ß√£o do invent√°rio e a constru√ß√£o da estrutura de fuga.A. Ordena√ß√£o Avan√ßada: Selection Sort por PrioridadeImplementaremos o Selection Sort para ordenar o invent√°rio do jogador com base em um crit√©rio estrat√©gico: Prioridade ou Tipo.Cen√°rio: O jogador precisa organizar o invent√°rio para ter os itens de cura (FOOD) ou os itens de fuga (PRIORITY_ITEM) no topo.Sele√ß√£o: A fun√ß√£o sortInventoryByPriority(Inventory) implementar√° o Selection Sort, buscando repetidamente o item de maior prioridade e trocando-o para a posi√ß√£o correta.Crit√©rio de Ordena√ß√£oDescri√ß√£oPrioridadeEnumere as prioridades: PRIORITY_ITEM (4) > WEAPON (3) > FOOD (2) > TOOL (1).AlgoritmoSelection Sort O(n¬≤): √â simples de implementar e adequado para o tamanho limitado do invent√°rio (MAX_INVENTORY_SIZE = 20).B. Constru√ß√£o L√≥gica da Torre de Fuga (Integra√ß√£o)

// L√≥gica da Torre de Fuga (escape.c)
#define ESCAPE_ITEM_ID 99
#define WOOD_NEEDED 50
#define METAL_NEEDED 30

void attemptEscape(Inventory *inv, ResourceList *res) {
    // 1. Verificar o Item Chave (Busca Bin√°ria no Invent√°rio)
    // Se o item de fuga (id=99) estiver presente, procede.
    int hasKeyItem = searchItem(inv, ESCAPE_ITEM_ID); 

    if (!hasKeyItem) {
        printf("FALHA: O item chave de fuga nao foi encontrado no inventario!\n");
        return;
    }

    // 2. Verificar Recursos (Busca na Lista Encadeada de Recursos)
    ResourceNode *wood = findResource(res, "Madeira");
    ResourceNode *metal = findResource(res, "Metal");

    if (wood && wood->quantity >= WOOD_NEEDED && metal && metal->quantity >= METAL_NEEDED) {
        // Sucesso na Fuga!
        printf("\n*** VITORIA! ***\n");
        printf("Todos os recursos e o item chave foram coletados. A Torre de Fuga esta completa!\n");
    } else {
        // Falha por falta de recursos
        printf("\nFALHA: Recursos insuficientes para a Torre de Fuga.\n");
        printf("Madeira: %d/%d, Metal: %d/%d\n", 
               wood ? wood->quantity : 0, WOOD_NEEDED, 
               metal ? metal->quantity : 0, METAL_NEEDED);
    }
}
